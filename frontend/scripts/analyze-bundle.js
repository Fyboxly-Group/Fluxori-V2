#!/usr/bin/env node

/**
 * Bundle analysis script for Fluxori-V2 frontend
 * 
 * This script:
 * 1. Runs a production build with bundle analysis
 * 2. Generates a detailed report of bundle sizes
 * 3. Provides optimization suggestions
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const chalk = require('chalk');

// Create reports directory if it doesn't exist
const reportsDir = path.join(__dirname, '../reports');
if (!fs.existsSync(reportsDir)) {
  fs.mkdirSync(reportsDir);
}

console.log(chalk.blue('ðŸ” Starting bundle analysis...'));

// Run build with bundle analyzer
try {
  console.log(chalk.yellow('Building project with bundle analyzer...'));
  
  // Set environment variable to enable bundle analyzer
  process.env.ANALYZE = 'true';
  
  // Install the webpack-bundle-analyzer if not already installed
  try {
    execSync('npm list webpack-bundle-analyzer --depth=0', { stdio: 'ignore' });
  } catch (e) {
    console.log(chalk.yellow('Installing webpack-bundle-analyzer...'));
    execSync('npm install --save-dev webpack-bundle-analyzer', { stdio: 'inherit' });
  }
  
  // Run the build
  execSync('npm run build', { stdio: 'inherit' });
  
  console.log(chalk.green('âœ… Build completed successfully with bundle analysis'));
} catch (error) {
  console.error(chalk.red('âŒ Build failed:'), error.message);
  process.exit(1);
}

// Generate a markdown report
try {
  console.log(chalk.yellow('Generating bundle size report...'));
  
  // Assume bundle-stats.json was generated by the analyzer
  const statsFile = path.join(__dirname, '../.next/stats.json');
  
  if (!fs.existsSync(statsFile)) {
    console.log(chalk.yellow('No stats.json file found. Using manual analysis method...'));
    
    // Get the build output and parse bundle sizes
    const buildOutput = fs.readdirSync(path.join(__dirname, '../.next/static/chunks'));
    
    const bundleSizes = buildOutput
      .filter(file => file.endsWith('.js'))
      .map(file => {
        const filePath = path.join(__dirname, '../.next/static/chunks', file);
        const size = fs.statSync(filePath).size;
        return {
          file,
          size,
          sizeFormatted: formatSize(size)
        };
      })
      .sort((a, b) => b.size - a.size);
    
    // Generate report
    generateManualReport(bundleSizes);
  } else {
    // Parse the stats file
    const statsData = JSON.parse(fs.readFileSync(statsFile, 'utf8'));
    
    // Generate detailed report
    generateFullReport(statsData);
  }
  
  console.log(chalk.green('âœ… Bundle analysis report generated'));
} catch (error) {
  console.error(chalk.red('âŒ Failed to generate report:'), error.message);
}

/**
 * Generate a manual report based on file sizes
 */
function generateManualReport(bundleSizes) {
  const now = new Date().toISOString().split('T')[0];
  const reportPath = path.join(reportsDir, `bundle-report-${now}.md`);
  
  let report = `# Bundle Size Analysis (${now})\n\n`;
  
  // Add overview
  report += `## Overview\n\n`;
  
  const totalSize = bundleSizes.reduce((sum, item) => sum + item.size, 0);
  report += `Total bundle size: ${formatSize(totalSize)}\n\n`;
  
  // Add largest bundles
  report += `## Largest Bundles\n\n`;
  report += `| File | Size |\n`;
  report += `|------|------|\n`;
  
  bundleSizes.slice(0, 10).forEach(item => {
    report += `| ${item.file} | ${item.sizeFormatted} |\n`;
  });
  
  // Add recommendations
  report += `\n## Recommendations\n\n`;
  report += `- Consider code splitting for large components\n`;
  report += `- Review large dependencies and look for alternatives\n`;
  report += `- Ensure tree shaking is working correctly\n`;
  report += `- Consider using dynamic imports for routes\n`;
  
  // Write the report
  fs.writeFileSync(reportPath, report);
  console.log(chalk.green(`Report saved to ${reportPath}`));
}

/**
 * Generate a full report based on Next.js stats
 */
function generateFullReport(statsData) {
  const now = new Date().toISOString().split('T')[0];
  const reportPath = path.join(reportsDir, `bundle-report-${now}.md`);
  
  let report = `# Bundle Size Analysis (${now})\n\n`;
  
  // Add overview
  report += `## Overview\n\n`;
  
  if (statsData.totalPageSize) {
    report += `Total bundle size: ${formatSize(statsData.totalPageSize)}\n\n`;
  }
  
  // Add page analysis if available
  if (statsData.pages) {
    report += `## Page Sizes\n\n`;
    report += `| Page | Size | First Load JS |\n`;
    report += `|------|------|---------------|\n`;
    
    Object.entries(statsData.pages)
      .sort((a, b) => {
        // Sort by size if available, otherwise alphabetically
        const sizeA = a[1].totalSize || 0;
        const sizeB = b[1].totalSize || 0;
        return sizeB - sizeA;
      })
      .forEach(([page, data]) => {
        const size = data.totalSize ? formatSize(data.totalSize) : 'N/A';
        const firstLoad = data.firstLoad ? formatSize(data.firstLoad) : 'N/A';
        report += `| ${page} | ${size} | ${firstLoad} |\n`;
      });
  }
  
  // Add bundle analysis if available
  if (statsData.chunks) {
    report += `\n## Chunk Analysis\n\n`;
    report += `| Chunk | Size | Imports |\n`;
    report += `|-------|------|--------|\n`;
    
    Object.entries(statsData.chunks)
      .sort((a, b) => b[1].size - a[1].size)
      .slice(0, 20) // Top 20 chunks
      .forEach(([chunk, data]) => {
        const size = formatSize(data.size);
        const imports = data.imports ? data.imports.join(', ') : 'None';
        report += `| ${chunk} | ${size} | ${imports} |\n`;
      });
  }
  
  // Add recommendations
  report += `\n## Recommendations\n\n`;
  
  // Generate specific recommendations
  const recommendations = [];
  
  // Check for large pages
  if (statsData.pages) {
    const largePages = Object.entries(statsData.pages)
      .filter(([_, data]) => data.totalSize > 300000) // 300KB threshold
      .map(([page]) => page);
    
    if (largePages.length > 0) {
      recommendations.push(
        `- **Large pages that could benefit from code splitting**: ${largePages.join(', ')}`
      );
    }

    // Find duplicate chunks across pages
    const pageChunks = {};
    Object.entries(statsData.pages).forEach(([page, data]) => {
      if (data.chunks) {
        data.chunks.forEach(chunk => {
          if (!pageChunks[chunk]) {
            pageChunks[chunk] = [];
          }
          pageChunks[chunk].push(page);
        });
      }
    });

    const duplicatedChunks = Object.entries(pageChunks)
      .filter(([_, pages]) => pages.length > 3)
      .map(([chunk, pages]) => ({ chunk, pageCount: pages.length }));

    if (duplicatedChunks.length > 0) {
      recommendations.push(
        `- **Chunks loaded by many pages** that should be moved to a shared bundle:`,
        ...duplicatedChunks.slice(0, 5).map(({ chunk, pageCount }) => 
          `  - ${chunk} (used by ${pageCount} pages)`
        )
      );
    }
  }

  // Check for large third-party dependencies
  const nodeModulesPattern = /\/node_modules\/([^/]+)/;
  const thirdPartyDeps = {};

  // Try to identify third-party dependencies in chunks
  if (statsData.chunks) {
    Object.entries(statsData.chunks).forEach(([_, data]) => {
      if (data.modules) {
        Object.keys(data.modules).forEach(module => {
          const match = module.match(nodeModulesPattern);
          if (match) {
            const depName = match[1];
            if (!thirdPartyDeps[depName]) {
              thirdPartyDeps[depName] = 0;
            }
            thirdPartyDeps[depName] += data.modules[module].size || 0;
          }
        });
      }
    });

    const largeThirdPartyDeps = Object.entries(thirdPartyDeps)
      .filter(([_, size]) => size > 50000) // 50KB threshold
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5);

    if (largeThirdPartyDeps.length > 0) {
      recommendations.push(
        `- **Large third-party dependencies** that should be optimized:`,
        ...largeThirdPartyDeps.map(([dep, size]) => 
          `  - ${dep}: ${formatSize(size)}`
        )
      );

      // Specific recommendations for known large dependencies
      const knownLargeDeps = {
        'gsap': 'Use dynamic imports to load GSAP plugins only when needed',
        '@mantine/core': 'Import specific components instead of the entire library',
        'moment': 'Consider replacing with a smaller alternative like date-fns',
        'lodash': 'Import specific functions instead of the entire library',
        'chart.js': 'Use dynamic imports to load chart components only when needed',
        'react-icons': 'Import specific icons instead of entire icon sets'
      };

      const specificDepsRecs = largeThirdPartyDeps
        .filter(([dep]) => knownLargeDeps[dep])
        .map(([dep]) => `  - ${dep}: ${knownLargeDeps[dep]}`);

      if (specificDepsRecs.length > 0) {
        recommendations.push(
          `- **Specific optimization strategies**:`,
          ...specificDepsRecs
        );
      }
    }
  }

  // Analyze client-side vs. server-side code split
  if (statsData.totalClientSize && statsData.totalServerSize) {
    const clientPercent = Math.round((statsData.totalClientSize / (statsData.totalClientSize + statsData.totalServerSize)) * 100);
    if (clientPercent > 70) {
      recommendations.push(
        `- **High client-side bundle ratio** (${clientPercent}%): Consider moving more logic to the server-side`
      );
    }
  }
  
  // Add optimization strategies
  recommendations.push(
    '- **Dynamic imports** for large components that are not needed immediately:',
    '  ```javascript',
    '  // Instead of: import LargeComponent from \'./LargeComponent\';',
    '  const LargeComponent = dynamic(() => import(\'./LargeComponent\'), {',
    '    loading: () => <LoadingComponent />',
    '  });',
    '  ```',
    '',
    '- **Implement route-based code splitting** for heavy features:',
    '  ```javascript',
    '  // This will be automatically code-split by Next.js',
    '  import dynamic from \'next/dynamic\';',
    '  const AdminPanel = dynamic(() => import(\'../components/AdminPanel\'));',
    '  ```',
    '',
    '- **Optimize image loading** with Next.js Image component:',
    '  ```javascript',
    '  import Image from \'next/image\';',
    '  // Use instead of <img> tags for better performance',
    '  <Image src="/image.jpg" alt="Description" width={500} height={300} />',
    '  ```',
    '',
    '- **Review CSS and styling approach** to reduce bundle size:',
    '  - Use CSS Modules for component-scoped styles',
    '  - Consider a utility-first CSS approach for consistency',
    '  - Import only the specific Mantine components you need',
    '',
    '- **Implement proper tree shaking** by using correct import syntax:',
    '  ```javascript',
    '  // BAD - imports entire library',
    '  import _ from \'lodash\';',
    '  ',
    '  // GOOD - only imports what\'s needed',
    '  import { debounce, throttle } from \'lodash-es\';',
    '  ```'
  );
  
  report += recommendations.join('\n');
  
  // Write the report
  fs.writeFileSync(reportPath, report);
  console.log(chalk.green(`Report saved to ${reportPath}`));
}

/**
 * Format a size in bytes to a human-readable string
 */
function formatSize(bytes) {
  if (bytes === 0) return '0 B';
  
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  
  return `${(bytes / Math.pow(1024, i)).toFixed(2)} ${sizes[i]}`;
}