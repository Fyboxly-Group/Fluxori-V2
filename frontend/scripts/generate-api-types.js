#!/usr/bin/env node

/**
 * API Response Type Generator
 * 
 * This script analyzes API usage patterns in the codebase and generates
 * TypeScript type definitions for API responses and request objects.
 */

const fs = require('fs').promises;
const path = require('path');
const util = require('util');
const glob = util.promisify(require('glob'));

// Configuration
const SCAN_DIR = path.resolve(__dirname, '../src');
const API_TYPES_FILE = path.resolve(__dirname, '../src/types/api.d.ts');
const API_HOOKS_DIR = path.resolve(__dirname, '../src/api');

// Command line arguments
const ARGS = {
  force: process.argv.includes('--force'),
  verbose: process.argv.includes('--verbose'),
};

// Logging
const log = (...args) => console.log(...args);
const verbose = (...args) => ARGS.verbose && console.log(...args);

// Common API response patterns
const API_RESPONSE_PATTERNS = [
  // Look for response type definitions
  { 
    regex: /export\s+(?:type|interface)\s+(\w+Response)\s*=?\s*(?:{([^}]*)})?\s*(?:extends\s+([^{]+))?\s*{?/g,
    extract: (match) => ({
      name: match[1],
      props: match[2] ? parseProps(match[2]) : [],
      extends: match[3] ? match[3].trim() : null,
    })
  },
  
  // Look for API function return types
  {
    regex: /export\s+(?:async\s+)?function\s+\w+\([^)]*\)\s*:\s*Promise<([^>]+)>/g,
    extract: (match) => ({
      name: `${generateTypeName(match[1])}Response`,
      type: match[1],
    })
  },
  
  // Look for useQuery hook return types
  {
    regex: /useQuery[<\(].*?[,\s](\w+)[,\s>]/g,
    extract: (match) => ({
      name: `${match[1]}Response`,
      isQueryResult: true,
    })
  },
];

// Helper to parse props from interface definition
function parseProps(propsText) {
  const propLines = propsText.split('\n').map(line => line.trim()).filter(Boolean);
  return propLines.map(line => {
    const [name, type] = line.split(/[:?]/).map(part => part.trim());
    return { name, type };
  });
}

// Helper to generate a type name from a type expression
function generateTypeName(typeExpr) {
  return typeExpr.trim()
    .replace(/[\s<>{}|\[\]()]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '');
}

/**
 * Find all TypeScript files in the src directory
 */
async function findTsFiles() {
  return glob(`${SCAN_DIR}/**/*.{ts,tsx}`, { 
    ignore: ['**/node_modules/**', '**/*.d.ts']
  });
}

/**
 * Analyze API-related TypeScript files
 */
async function analyzeApiFiles() {
  log('ðŸ” Scanning for API usage patterns...');
  
  // Find all TypeScript files
  const allFiles = await findTsFiles();
  log(`Found ${allFiles.length} TypeScript files to scan`);
  
  // Filter for files likely to contain API definitions
  const apiFiles = allFiles.filter(file => 
    file.includes('/api/') || 
    file.includes('.api.') || 
    file.includes('/hooks/') ||
    file.includes('/services/')
  );
  
  log(`Found ${apiFiles.length} files likely to contain API definitions`);
  
  // Collect API type definitions
  const apiTypeDefinitions = new Map();
  
  for (const file of apiFiles) {
    verbose(`Analyzing ${file}...`);
    const content = await fs.readFile(file, 'utf8');
    
    // Check each regex pattern
    for (const pattern of API_RESPONSE_PATTERNS) {
      let match;
      while ((match = pattern.regex.exec(content)) !== null) {
        const typeInfo = pattern.extract(match);
        
        if (typeInfo && typeInfo.name) {
          apiTypeDefinitions.set(typeInfo.name, {
            ...typeInfo,
            sourceFile: file,
          });
          verbose(`Found API type: ${typeInfo.name}`);
        }
      }
    }
  }
  
  return apiTypeDefinitions;
}

/**
 * Generate type definitions with proper extended interfaces
 */
function generateTypeDefinitions(apiTypes) {
  // Start with common API response types
  let output = `// Generated API type definitions
// This file is automatically generated - do not edit directly

/**
 * Standard API response envelope
 */
export interface ApiResponse<T> {
  data: T;
  success: boolean;
  message?: string;
  error?: string;
}

/**
 * Paginated API response
 */
export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    totalPages: number;
    totalItems: number;
  };
  total: number;
  count: number;
}

/**
 * Error response
 */
export interface ApiErrorResponse {
  error: string;
  message: string;
  status: number;
}

`;

  // Add utility type for safe response handling
  output += `/**
 * Utility type for safely accessing API response data
 * Use like: SafeApiResponse<YourType>
 */
export type SafeApiResponse<T> = ApiResponse<T> | T;
`;

  // Add generated interfaces
  output += `\n// Generated interface definitions\n`;
  for (const [name, typeInfo] of apiTypes.entries()) {
    // Skip duplicates
    if (output.includes(`export interface ${name}`)) {
      continue;
    }
    
    // Generate interface
    if (typeInfo.isQueryResult) {
      output += `
/**
 * Query result type for ${name}
 * Source: ${path.relative(SCAN_DIR, typeInfo.sourceFile)}
 */
export interface ${name} {
  data: any;
  isLoading: boolean;
  isError: boolean;
  error: unknown;
}\n`;
    }
    else if (typeInfo.props) {
      const extendsClause = typeInfo.extends ? ` extends ${typeInfo.extends}` : '';
      
      output += `
/**
 * API response interface for ${name}
 * Source: ${path.relative(SCAN_DIR, typeInfo.sourceFile)}
 */
export interface ${name}${extendsClause} {
  ${typeInfo.props.map(prop => `${prop.name}: ${prop.type || 'any'};`).join('\n  ')}
}\n`;
    }
    else if (typeInfo.type) {
      output += `
/**
 * API response type for ${name}
 * Source: ${path.relative(SCAN_DIR, typeInfo.sourceFile)}
 */
export type ${name} = ${typeInfo.type};\n`;
    }
  }
  
  return output;
}

/**
 * Main function
 */
async function main() {
  log('âœ¨ API Response Type Generator âœ¨');
  
  // Create types directory if it doesn't exist
  const typesDir = path.dirname(API_TYPES_FILE);
  try {
    await fs.mkdir(typesDir, { recursive: true });
  } catch (err) {
    if (err.code !== 'EEXIST') throw err;
  }
  
  // Analyze API usage
  const apiTypes = await analyzeApiFiles();
  log(`Found ${apiTypes.size} API type definitions`);
  
  if (apiTypes.size === 0 && !ARGS.force) {
    log('No API types found. Exiting...');
    return;
  }
  
  // Generate type definitions
  const typeDefinitions = generateTypeDefinitions(apiTypes);
  
  // Check if the file already exists
  let existingContent = '';
  try {
    existingContent = await fs.readFile(API_TYPES_FILE, 'utf8');
  } catch (err) {
    // File doesn't exist yet
    log(`Creating new API types file: ${API_TYPES_FILE}`);
  }
  
  // Only update if content changed or force is true
  if (existingContent !== typeDefinitions || ARGS.force) {
    await fs.writeFile(API_TYPES_FILE, typeDefinitions);
    log(`âœ… Generated API type definitions in ${API_TYPES_FILE}`);
  } else {
    log('â„¹ï¸ API type definitions are up to date');
  }
}

// Run the script
main().catch(err => {
  console.error('Error:', err);
  process.exit(1);
});